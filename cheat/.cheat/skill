### Shell技巧
Advanced Bash-Scripting Guide : https://tldp.org/LDP/abs/html/index.html
[shell特殊字符_-_云_社区_-_腾讯云.pdf](http://wiki.kosolo.cn/data/files/yun.pdf)

```bash
+++++ 自动生成密码
echo qspace:$(base64 < /dev/urandom | head -c15) | chpasswd

+++++将字符串分割成数组，类似split：
1  arr=(`echo $str | tr "delimit" " "`)
2  IFS="delimit";  arr=($str)                   #要保存原有的IFS，得多加语句

++++++字符串截取：
假设变量 str 值为 oh_123_my_123_god

## 为从左到右匹配，尽多匹配，然后去掉匹配的字符串
#  为从左到右匹配，尽少匹配，然后去掉匹配的字符串
%% 为从右到做匹配，尽多匹配，然后去掉匹配的字符串
%  为从右到做匹配，尽少匹配，然后去掉匹配的字符串
${str#trimstart} ${str%trimend}
${str//search/repl}
${varible:a:b} 


++++++read从字符串输入
read -a arr <<< $(echo $str)

++++++打印有颜色的字符串
echo -e "\e[1;33m这些字都是有颜色的\e[0m" 1>&2
\e[ 后面的控制样式：
0 关闭所有属性
1 设置高亮度
4 下划线
5 闪烁
7 反显
8 消隐
30 黑色字
31 红色字
32 绿色字
33 黄色字
34 蓝色字
35 紫色字
36 天蓝字
37 白色字
40~47控制字的背景色，40是黑色背景，41是红色....

++++++ 需要打印多行文字的时候
conf=$(cat <<EOF
uid=qspace
gid=users
EOF)
echo -e "$conf" #这里的双引号必须加

++++++ $* 和 $@ 详解  （结论：推荐用"$@"，做参数传递）
https://unix.stackexchange.com/questions/41571/what-is-the-difference-between-and
https://blog.csdn.net/whuslei/article/details/7187639

1 $* 和 $@ 没有被 "" 包围，则这两者一样，千万不要用于参数传递，比如 a b "c d" ，会被当成 a b c d处理
2 "$*" 和 "$@" 有区别
  "$*" 用IFS变量的第一个字符将所有参数连接起来，可用于参数连接
  "$@" 则会保留原来参数的完整样子，即使参数中含义空格
 测试用例：
 a.sh
echo $#
IFS="-bj"
echo "$*"
sh b.sh "$@"

  b.sh
echo $#
echo;echo "\$@"; for i in $@;do echo $i;done
echo;echo "\"\$@\""; for i in "$@"; do echo $i; done
echo;echo "\$*"; for i in $*; do echo $i; done
echo;echo "\"\$*\"";for i in "$*";do echo $i; done


+++++ 打印彩色日志函数
INFO() {
    echo -e "\e[1;34m[$(date "+%Y-%m-%d %H:%M:%S")][INFO]: $TAG $IP:$PORT $1\e[0m"
}
WARN() {
    echo -e "\e[1;33m[$(date "+%Y-%m-%d %H:%M:%S")][WARN]: $TAG $IP:$PORT $1\e[0m"
}

ERROR() {
	echo -e "\e[1;31m[ERROR]: $1\e[0m"
	[[ $# -lt 2 ]] && exit 1 || exit $2
}

+++++ 数组的添加元素/合并操作
arr+=("$ele")
Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
Shell=('bash' 'csh' 'jsh' 'rsh' 'ksh' 'rc' 'tcsh');
UnixShell=("${Unix[@]}" "${Shell[@]}")
echo ${UnixShell[@]}
echo ${#UnixShell[@]}


+++++ bash4以上才支持关联数组
declare -A assArr
assArr[aaa]=bbb
assArr[$var]=ccc
echo ${assArr[@]}  # 数组的所有value
echo ${!assArr[@]} # 数组的所有key
echo ${#assArr[@]} # 数组的长度

+++++ !的作用
echo "hello!" 会报错: -bash: !: event not found
因为!后面紧接其他单词, 表示搜索最后一条以该单词开头的执行过的shell命令, 并替换该命令, 搜索不到则报错

+++++ 判断文件是否存在某行, 不存在则添加
INFO() {
	echo "$@"
}

insert_if_not() {
	pat=$1
	line=$2
	file=$3
	content=$(grep -P "$pat"  $file)
	if [[ "$content" == '' ]]; then
		INFO "pattern $pat not in $file"
		sed -i "1 i $line"  $file
	else
		INFO "pattern $pat is in $file, not need modify"
	fi
}

rsync_conf=/etc/rsyncd.conf
insert_if_not "^\s*gid\s*=\s*users\b" "gid=users" $rsync_conf
insert_if_not "^\s*uid\s*=\s*qspace\b" "uid=qspace" $rsync_conf
insert_if_not "^\s*secrets file\s*=\s*/etc/rsyncd.secrets\b" "secrets file = /etc/rsyncd.secrets"  $rsync_conf

+++++ 脚本内部重定向
https://stackoverflow.com/questions/314675/how-to-redirect-output-of-an-entire-shell-script-within-the-script-itself
error_log=/tmp/run_error.$$
exec 2> >(tee -a $error_log)
get_error_msg() {
cat $error_log
}

+++++ awk 表达式中使用shell变量
port=3306
# 其中port为shell变量, '$port' 或者 '"$port"' 都行
awk  '{if ($1 == "tcp") { localaddr=$5; remoteaddr=$6 } else { localaddr=$4; remoteaddr=$5  }; if (localaddr ~ /:'$port'$/) print $0}' 


+++++ 重复执行检测
check_running() {
    FLAG=/tmp/is_running.flag
    [ -f $FLAG ] && FINAL_FAIL "$0 is in process" && exit 2
    touch $FLAG
    trap "rm $FLAG" EXIT
    return 0
}

+++++ 解析json字段
function parse_json() {
    echo $1 | sed 's/.*"'$2'":\([^,}]*\).*/\1/'
}

+++++ 按进程打卡的文件描述符排序
for dir in ls /proc/[0-9]* -d; do echo "$dir $(ls $dir/fd 2>/dev/null | wc -l)"; done | sort -k 2 -n  | tail -n 10
```
### 快捷键
```bash
常用
ctrl+左右键:在单词之间跳转
ctrl+a:跳到本行的行首
ctrl+e:跳到页尾
Ctrl+u：删除当前光标前面的文字 （还有剪切功能）
ctrl+k：删除当前光标后面的文字(还有剪切功能)
Ctrl+L：进行清屏操作
Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容
Ctrl+w:删除光标前面的单词的字符
Alt – d ：由光标位置开始，往右删除单词。往行尾删

说明
Ctrl – k: 先按住 Ctrl 键，然后再按 k 键；
Alt – k: 先按住 Alt 键，然后再按 k 键；
M – k：先单击 Esc 键，然后再按 k 键。

移动光标
Ctrl – a ：移到行首
Ctrl – e ：移到行尾
Ctrl – b ：往回(左)移动一个字符
Ctrl – f ：往后(右)移动一个字符
Alt – b ：往回(左)移动一个单词
Alt – f ：往后(右)移动一个单词
Ctrl – xx ：在命令行尾和光标之间移动
M-b ：往回(左)移动一个单词
M-f ：往后(右)移动一个单词

编辑命令
Ctrl – h ：删除光标左方位置的字符
Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会注销系统或结束终端）
Ctrl – w ：由光标位置开始，往左删除单词。往行首删
Alt – d ：由光标位置开始，往右删除单词。往行尾删
M – d ：由光标位置开始，删除单词，直到该单词结束。
Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。
Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。
Ctrl – y ：粘贴之前删除的内容到光标后。
ctrl – t ：交换光标处和之前两个字符的位置。
Alt + . ：使用上一条命令的最后一个参数。
Ctrl – _ ：回复之前的状态。撤销操作。
Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。

Bang(!)命令
!! ：执行上一条命令。
foobar ：把上一条命令里的foo替换为bar，并执行。
!wget ：执行最近的以wget开头的命令。
!wget:p ：仅打印最近的以wget开头的命令，不执行。
!$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。
!* ：上一条命令的所有参数
!*:p ：打印上一条命令是所有参数，也即 !*的内容。
^abc ：删除上一条命令中的abc。
foobar ：将上一条命令中的 foo 替换为 bar
foobar^ ：将上一条命令中的 foo 替换为 bar
!-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5

查找历史命令
Ctrl – p ：显示当前命令的上一条历史命令
Ctrl – n ：显示当前命令的下一条历史命令
Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。
Ctrl – g ：从历史搜索模式（Ctrl – r）退出。

控制命令
Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。
Ctrl – o ：执行当前命令，并选择上一条命令。
Ctrl – s ：阻止屏幕输出
Ctrl – q ：允许屏幕输出
Ctrl – c ：终止命令
Ctrl – z ：挂起命令

重复执行操作动作
M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。
```

